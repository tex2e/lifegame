各言語によるLifegame
===================

内容
--------
ライフゲーム（lifegame）を私が知っている言語で実装したものを集めたレポジトリです。
私が何種類の言語を使えるかを説明できるようにするために、まとめているだけです。

実装方針
--------
クラス、もしくはクラスに類似する機能がその言語にある場合は、勉強のためにできるだけクラスを使って実装します。
その際に必要となるフィールドを以下に示します。

| 名前 | 型 | 説明 |
| :-------- | :------ | :------------- |
| field     | int[][] | ライフゲームの盤面の状態を表す |

また、必要となるメソッドを以下に示します。
ただし、全てがこの通りではありません。場合によっては例外もあります。


| 名前と型 | 説明 |
| :-------------- | :------------- |
| init_field()        | ライフゲームの初期状態を0か1のランダムに初期化する
| evolve() -> int[][] | ライフゲームの状態を次の世代にする
| count_alive_neighbours(y, x) | 座標 (x, y) の周りの生きてるセルの数を数える
| mod(a, b) -> int    | a 割る b の余りを求めるが、この結果は必ず正数になるようにする
| dump_field()        | ライフゲームの盤面をコンソールに出力する
| clear_screen()      | コンソールの表示をクリアする

また可能な限り、外部ライブラリなどには依存しない方向ですが、言語によっては乱数生成ライブラリが標準でなかったり、
二次元配列を扱うための良いライブラリがある場合には、外部ライブラリを使うこともあるのでご了承ください。

得られる知識
------------
ある言語を使ってLifegameを実装したときに得られる知識には以下のようなものがあります。

- 条件文、ループ文（関数型言語では再帰）
- 二次元配列の定義、要素への代入、要素の取得
- 実行時に配列のサイズが決まる動的配列が使えるか否か
- 乱数の生成
- 配列のディープコピー
- パターンマッチ（関数型言語）
- クラス、メソッド、フィールドの定義
- あるメソッドから別のメソッドを呼び出す方法（self, this）
- 100 [ms] のスリープをする方法
- 外部コマンドの実行（clearコマンド）
